// api/internal/adapters/nginx_manager.go
package adapters

import (
	"bytes"
	"context"
	"fmt"
	"log/slog"
	"text/template"

	"kari/api/internal/config"
	"kari/api/internal/core/domain"
	"kari/api/internal/grpc/rustagent" // Our generated gRPC client
)

// ==============================================================================
// 1. Adapter Struct & Dependency Injection
// ==============================================================================

type NginxManager struct {
	Config      *config.Config
	AgentClient rustagent.SystemAgentClient
	Logger      *slog.Logger
	Template    *template.Template
}

// NewNginxManager parses the template once at startup to fail fast if there's a syntax error.
func NewNginxManager(cfg *config.Config, agentClient rustagent.SystemAgentClient, logger *slog.Logger) *NginxManager {
	tmpl := template.Must(template.New("nginx_vhost").Parse(nginxTemplate))
	return &NginxManager{
		Config:      cfg,
		AgentClient: agentClient,
		Logger:      logger,
		Template:    tmpl,
	}
}

// ==============================================================================
// 2. Concrete Implementation of the WebServerManager SLA
// ==============================================================================

func (m *NginxManager) ApplyConfig(ctx context.Context, appConfig domain.WebServerConfig) error {
	m.Logger.Info("Generating Nginx configuration", slog.String("domain", appConfig.DomainName))

	// 1. Compile the Template
	// We inject the dynamic paths directly from the Config struct (Environment Agnostic)
	data := struct {
		DomainName string
		Port       int
		HasSSL     bool
		SSLDir     string
	}{
		DomainName: appConfig.DomainName,
		Port:       appConfig.LocalPort,
		HasSSL:     appConfig.HasSSL,
		SSLDir:     m.Config.SSLStorageDir, // e.g., "/etc/kari/ssl"
	}

	var buf bytes.Buffer
	if err := m.Template.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute Nginx template: %w", err)
	}

	// 2. Transmit to the Rust Agent
	// The Go Brain does not touch the disk. It sends the payload via gRPC.
	configPath := fmt.Sprintf("%s/%s.conf", m.Config.NginxConfPath, appConfig.DomainName)
	
	writeReq := &rustagent.FileWriteRequest{
		TraceId:      fmt.Sprintf("nginx-%s", appConfig.DomainName),
		AbsolutePath: configPath,
		Content:      buf.Bytes(),
		Owner:        "root",
		Group:        "root",
		FileMode:     "0644",
	}

	if _, err := m.AgentClient.WriteSystemFile(ctx, writeReq); err != nil {
		return fmt.Errorf("agent failed to write Nginx config: %w", err)
	}

	// 3. Command the Rust Agent to reload the Nginx Daemon securely
	reloadReq := &rustagent.ServiceRequest{
		ServiceName: "nginx",
		Action:      rustagent.ServiceAction_RELOAD,
	}

	if _, err := m.AgentClient.ManageService(ctx, reloadReq); err != nil {
		return fmt.Errorf("agent failed to reload Nginx: %w", err)
	}

	m.Logger.Info("âœ… Nginx configuration successfully applied", slog.String("domain", appConfig.DomainName))
	return nil
}

func (m *NginxManager) RemoveConfig(ctx context.Context, domainName string) error {
	// To remove a config, we just ask the Rust agent to run a targeted package command
	// to delete the file, then reload Nginx.
	configPath := fmt.Sprintf("%s/%s.conf", m.Config.NginxConfPath, domainName)
	
	removeReq := &rustagent.PackageRequest{
		Command: "rm",
		Args:    []string{"-f", configPath},
	}

	if _, err := m.AgentClient.ExecutePackageCommand(ctx, removeReq); err != nil {
		return fmt.Errorf("agent failed to remove Nginx config: %w", err)
	}

	// Reload daemon
	reloadReq := &rustagent.ServiceRequest{
		ServiceName: "nginx",
		Action:      rustagent.ServiceAction_RELOAD,
	}
	_, err := m.AgentClient.ManageService(ctx, reloadReq)
	
	return err
}

// ==============================================================================
// 3. The Nginx Configuration Template
// ==============================================================================

// This template is strict, opinionated, and highly secure.
// It forces HTTP to HTTPS redirects, prevents framing (Clickjacking),
// disables content sniffing, and strictly forwards WebSocket upgrade headers.
const nginxTemplate = `
# Automatically generated by Kari. DO NOT EDIT MANUALLY.
# Domain: {{.DomainName}}

{{if .HasSSL}}
# HTTP -> HTTPS Redirect
server {
    listen 80;
    listen [::]:80;
    server_name {{.DomainName}};
    
    location /.well-known/acme-challenge/ {
        root /var/www/html;
        allow all;
    }

    location / {
        return 301 https://$host$request_uri;
    }
}

# HTTPS Server Block
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name {{.DomainName}};

    # SSL Configuration (Paths injected dynamically from Kari Config)
    ssl_certificate {{.SSLDir}}/{{.DomainName}}/fullchain.pem;
    ssl_certificate_key {{.SSLDir}}/{{.DomainName}}/privkey.pem;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
{{else}}
# HTTP-Only Server Block (Awaiting SSL Provisioning)
server {
    listen 80;
    listen [::]:80;
    server_name {{.DomainName}};

    location /.well-known/acme-challenge/ {
        root /var/www/html;
        allow all;
    }
{{end}}

    # Security Headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Reverse Proxy to Kari systemd local port
    location / {
        proxy_pass http://127.0.0.1:{{.Port}};
        
        # Standard Proxy Headers
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket Support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts (Adjusted for long-running Next.js / Node APIs)
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}
`
